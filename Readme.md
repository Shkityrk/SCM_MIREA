# Задание №1 (hw_1)
## Постановка задачи
Разработать эмулятор для языка оболочки ОС. Необходимо сделать работу эмулятора как можно более похожей на сеанс shell в UNIX-подобной ОС. Эмулятор должен запускаться из реальной командной строки, а файл с виртуальной файловой системой не нужно распаковывать у пользователя. Эмулятор принимает образ виртуальной файловой системы в виде файла формата tar. Эмулятор должен работать в режиме CLI.

Конфигурационный файл имеет формат toml и содержит:
* Имя компьютера для показа в приглашении к вводу.
* Путь к архиву виртуальной файловой системы.

Необходимо поддержать в эмуляторе команды ls, cd и exit, а также следующие команды:
1. rev.
2. uname.

Все функции эмулятора должны быть покрыты тестами, а для каждой из поддерживаемых команд необходимо написать 3 теста.

## Необходимые требования
### Установка Poetry

Установить Poetry, выполнив команду для установки:

```bash
curl -sSL https://install.python-poetry.org | python3 -
```

### Установка зависимостей poetry
Чтобы установить все зависимости проекта с помощью Poetry, нужно выполнить команду:

```bash
poetry install
```

### Создание конфигурационных файлов
В папке hw_1/src необходимо создать папку .env, которая будет содержать:
* config.toml - конфигурационный файл
```toml
[system]
hostname = "my_computer_name"

[filesystem]
path = "path_to_your_project/hw_1/src/env/filesystem.tar"
```
* filesystem.tar - заархивированная файловая система


## Запуск эмулятора

Запуск эмулятора осуществляется с помощью команды

```bash
poetry run python hw_1/main.py
```

## Описание команд
### Команда ``cd [directory]``
Осуществляет переход от настоящей папки к заданной в параметре directory

- `directory` (обязательный): Путь к целевой директории, в которую вы хотите перейти. Может быть указан как абсолютный, так и относительный путь.

**Пример:**

```bash
cd home
```

### Команда ``ls ``
Возвращает список файлов и папок в данной директории


**Пример:**

```bash
ls
```

### Команда `exit`

Завершает работу текущей командной оболочки или эмулятора.


**Пример:**

```bash
exit
```

### Команда `rev [string]`

Выводит строку `string` в обратном порядке.

**Параметры:**

- `string` (обязательный): Строка, которую необходимо перевернуть.

**Пример:**

```bash
rev hello
# Вывод: olleh
```

### Команда `uname`

Выводит информацию о системе, включая имя операционной системы, имя узла, версию ядра и другую системную информацию.

**Пример:**

```bash
uname
# Вывод: Windows
````
## Запуск тестов

Для запуска тестов с использованием pytest выполните следующую команду:

```bash
pytest hw_1/src/tests/tests.py
```


# Задание №2 (hw_2)
## Постановка задачи
Разработать инструмент командной строки для визуализации графа зависимостей, включая транзитивные зависимости. Сторонние программы или библиотеки для получения зависимостей использовать нельзя.
Зависимости определяются для файла-пакета языка Python. Для описания графа зависимостей используется представление PlantUML. Визуализатор должен выводить результат в виде сообщения об успешном выполнении и сохранять граф в файле формата png.
Конфигурационный файл имеет формат csv и содержит:
* Путь к программе для визуализации графов.
* Путь к анализируемому пакету.
* Путь к файлу с изображением графа зависимостей.
* Максимальная глубина анализа зависимостей.
Все функции визуализатора зависимостей должны быть покрыты тестами.

## Подготовка к запуску
* Установить зависимости 
* Создать папку env, в нее поместить файл graph.uml, jar-файл программы plantuml
* Откорректировать пути файлов в файле ``src/config/config.py``

## Запуск проекта
```bash
poetry run python hw_2/main.py
```

# Задание 3 (hw_3)
pass


# Задание 4 (hw_4)
Этот проект включает в себя ассемблер и интерпретатор для учебной виртуальной машины (УВМ). Ассемблер преобразует исходный текст программы в бинарный формат, а интерпретатор выполняет программу, сохранённую в бинарном виде.

## Структура проекта

```
root:.
└───src
    ├───assemble
    │   │   assembler.py      # Скрипт для ассемблера
    │   │   log_assemble.json # Лог ассемблирования
    │   │   program.bin      # Бинарный файл программы
    │   └───__pycache__      # Кэшированные файлы Python
    ├───config
    │       input.asm         # Исходный код на ассемблере
    ├───interpret
    │   │   interpretator.py # Скрипт для интерпретатора
    │   │   result.json      # Результат выполнения программы
    │   └───__pycache__      # Кэшированные файлы Python
    └───tests
        │   log.json         # Лог выполнения программы
        │   program.bin     # Бинарная версия программы
        │   result.json     # Ожидаемый результат выполнения
        │   tests.py        # Тесты для программы
        └───__pycache__     # Кэшированные файлы Python
```

## Использование

### Шаг 1: Сборка бинарного файла с помощью ассемблера

1. Подготовьте исходный код программы в файле `src/config/input.asm`. Пример:

   ```
   LOAD_CONST A=7 B=414
   READ A=3 B=767
   WRITE A=4 B=403
   SHIFT_RIGHT A=2 B=683
   ```

2. Запустите ассемблер, чтобы преобразовать программу в бинарный файл и создать лог:

   ```bash
   python src/assemble/assembler.py src/config/input.asm src/assemble/program.bin src/assemble/log_assemble.json
   ```

   После выполнения команды:
   - `program.bin` будет содержать бинарное представление программы.
   - Лог будет записан в `log_assemble.json`.

### Шаг 2: Интерпретация бинарного файла

После того как программа собрана, её можно выполнить с помощью интерпретатора.

1. Запустите интерпретатор:

   ```bash
   python src/interpret/interpretator.py src/assemble/program.bin src/interpret/result.json
   ```

   Это выполнит программу из `program.bin` и сохранит результат выполнения в `result.json`.

## Тестирование

Для тестирования программы используйте файл `src/tests/tests.py`. Он включает в себя набор тестов, который проверяет правильность работы ассемблера и интерпретатора.

Запустите тесты с помощью `pytest`:

```bash
pytest src/tests/tests.py
```

## Формат файлов

- **input.asm**: Исходный код программы на ассемблере.
- **program.bin**: Бинарное представление программы.
- **log_assemble.json**: Лог процесса ассемблирования.
- **result.json**: Результат выполнения программы интерпретатором.
- **tests.py**: Тесты для ассемблера и интерпретатора.
